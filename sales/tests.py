from core.testcases import APIModelViewSetTestCase, ModelViewSetTestCase, get_permissions_from_compact
from rest_framework import status
from sales.models import *

# Used for Association, Sale, ItemGroup, Item, ItemField
ManagerOrReadOnly = get_permissions_from_compact({
	'list':     'puoa',    # Everyone can list
	'retrieve': 'puoa',    # Everyone can retrieve
	'create':   '...a',    # Only admin can create
	'update':   '...a',    # Only managers & admin can update
	'delete':   '...a',    # Only admin can delete
})

# Used for Order, OrderLine, OrderLineItem, OrderLineField
OrderOwnerOrAdmin = get_permissions_from_compact({
	'list':     '...a',    # Only admin can list
	'retrieve': '.u.a',    # Only owner and admin can retrieve
	'create':   '.u.a',    # Only owner and admin can create
	'update':   '.u.a',    # Only owner and admin can update
	'delete':   '.u.a',    # Only owner and admin can delete
})


class AssociationViewSetTestCase(APIModelViewSetTestCase):
	model = Association
	permissions = ManagerOrReadOnly

# TODO check visibilities
class SaleViewSetTestCase(ModelViewSetTestCase):
	model = Sale
	permissions = ManagerOrReadOnly


class ItemGroupViewSetTestCase(ModelViewSetTestCase):
	model = ItemGroup
	permissions = ManagerOrReadOnly

# TODO test different usertypes
class ItemViewSetTestCase(ModelViewSetTestCase):
	model = Item
	permissions = ManagerOrReadOnly


class OrderViewSetTestCase(ModelViewSetTestCase):
	model = Order
	permissions = {
		**OrderOwnerOrAdmin,
		# Every logged user can create order
		'create': { 'public': False, 'user': True, 'other': True, 'admin': True },
	}

	def additionnal_setUp(self):
		self.sale = self.modelFactory.create(Sale)

	def get_object_attributes(self, user: 'User'=None, withPk: bool=True) -> dict:
		return self.modelFactory.get_attributes(self.model, withPk=withPk, sale=self.sale, owner=user)

	def create_object(self, user: 'User'=None) -> Order:
		data = self.get_object_attributes(user, withPk=False)
		data['status'] = OrderStatus.AWAITING_PAYMENT.value
		return self.model.objects.create(**data)

	def get_url(self, pk=None) -> str:
		return super().get_url(pk) + "?all"

	def get_expected_status_code(self, method: str, allowed: bool, user: str):
		if allowed and method == 'post':
			return status.HTTP_200_OK if user == 'user' else status.HTTP_201_CREATED
		return super().get_expected_status_code(method, allowed, user)


	def test_order_update(self):
		"""
		Test the response generated by an order update
		"""
		order = self.object

		# Map of possible transitions:
		# { (old_status, new_status): redirect_to_payment, tickets_generated }
		POSSIBLE_TRANSITIONS = {
			('ONGOING',             'AWAITING_VALIDATION'): (False, False),
			('ONGOING',             'AWAITING_PAYMENT'):    (True,  False),
			('ONGOING',             'EXPIRED'):             (False, False),
			('ONGOING',             'CANCELLED'):           (False, False),

			('AWAITING_VALIDATION', 'VALIDATED'):           (False, True),
			('AWAITING_VALIDATION', 'EXPIRED'):             (False, False),
			('AWAITING_VALIDATION', 'CANCELLED'):           (False, False),

			('AWAITING_PAYMENT',    'PAID'):                (False, True),
			('AWAITING_PAYMENT',    'EXPIRED'):             (False, False),
			('AWAITING_PAYMENT',    'CANCELLED'):           (False, False),
		}
		ALL_STATES = [ name for value, name in OrderStatus.choices() ]

		# TODO combinations_with_replacement(ALL_STATES, 2):
		# from itertools import combinations_with_replacement
		for key in POSSIBLE_TRANSITIONS:
			old_status, new_status = [ getattr(OrderStatus, k) for k in key ]
			tr = f"({old_status.name} -> {new_status.name})"

			order.status = old_status.value
			order.save()
			resp = order.update_status(new_status)

			self.assertEqual(resp['old_status'], old_status.name, f"Wrong old status {tr}")

			if key in POSSIBLE_TRANSITIONS:
				redirect, generate = POSSIBLE_TRANSITIONS[key]

				self.assertEqual(resp['status'], new_status.name, f"Wrong new status {tr}")
				self.assertEqual(resp['message'], OrderStatus.MESSAGES.value[new_status.value], f"Wrong message {tr}")
				self.assertEqual(resp['updated'], True, f"Different updated {tr}")
				self.assertEqual(resp['redirect_to_payment'], redirect, f"Different redirect {tr}")
				self.assertEqual(resp['tickets_generated'], generate, f"Different tickets_generated {tr}")

class OrderLineViewSetTestCase(ModelViewSetTestCase):
	model = OrderLine
	permissions = OrderOwnerOrAdmin

	def additionnal_setUp(self):
		# Order is own by user for the purpose of the tests
		self.order = self.modelFactory.create(Order, owner=self.users['user'])
		self.assertEqual(self.order.owner, self.users['user'],
		                 "Erreur de configuration, l'order doit être faite par 'user'")

	def get_object_attributes(self, user: 'User'=None, withPk: bool=True) -> dict:
		options = {
			'order': self.order,
			'quantity': 5
		}
		return self.modelFactory.get_attributes(self.model, withPk=withPk, **options)
		
	def get_url(self, pk=None) -> str:
		return super().get_url(pk) + "?all"


class FieldViewSetTestCase:
# class FieldViewSetTestCase(ModelViewSetTestCase):
	model = Field
	permissions = ManagerOrReadOnly

class ItemFieldViewSetTestCase:
# class ItemFieldViewSetTestCase(ModelViewSetTestCase):
	model = ItemField
	permissions = ManagerOrReadOnly


class OrderLineItemViewSetTestCase:
# class OrderLineItemViewSetTestCase(ModelViewSetTestCase):
	model = OrderLineItem
	permissions = get_permissions_from_compact({
		'list':     '...a', 	# Only admin can list
		'retrieve': '.u.a', 	# Only owner and admin can retrieve
		'create':   '...a', 	# Only admin can create
		'update':   '...a', 	# Only admin can update
		'delete':   '...a', 	# Only admin can delete
	})

	def additionnal_setUp(self):
		# Order is own by user for the purpose of the tests
		self.order = self.modelFactory.create(Order, owner=self.users['user'])
		self.orderline = self.modelFactory.create(OrderLine, order=self.order)
		self.assertEqual(self.orderline.order.owner, self.users['user'], "Erreur de configuration, l'order doit être faite par 'user'")

	def get_object_attributes(self, user: 'User'=None, withPk: bool=True) -> dict:
		return self.modelFactory.get_attributes(self.model, withPk=withPk, orderline=self.orderline)


class OrderLineFieldViewSetTestCase:
# class OrderLineFieldViewSetTestCase(ModelViewSetTestCase):
	model = OrderLineField
	permissions = get_permissions_from_compact({
		'list':     '...a', 	# Only admin can list
		'retrieve': '.u.a', 	# Only owner and admin can retrieve
		'create':   '...a', 	# Only admin can create
		'update':   '.u.a', 	# Only admin can update
		'delete':   '...a', 	# Only admin can delete
	})

	def additionnal_setUp(self):
		self.item = self.modelFactory.create(Item)
		self.field = self.modelFactory.create(Field)
		self.itemfield = self.modelFactory.create(ItemField, item=self.item, field=self.field, editable=True)

		# Order is own by user for the purpose of the tests
		self.order = self.modelFactory.create(Order, owner=self.users['user'])
		self.orderline = self.modelFactory.create(OrderLine, order=self.order, item=self.item, quantity=1)
		self.orderlineitem = self.modelFactory.create(OrderLineItem, orderline=self.orderline)

		# Tests
		self.assertEqual(self.orderlineitem.orderline.order.owner, self.users['user'])
		self.assertEqual(self.orderlineitem.orderline.item, self.item)
		self.assertEqual(self.itemfield.item, self.item)
		self.assertEqual(self.itemfield.field, self.field)

	def get_object_attributes(self, user: 'User'=None, withPk: bool=True) -> dict:
		options = {
			'orderlineitem': self.orderlineitem,
			'field': self.field,
		}
		return self.modelFactory.get_attributes(self.model, withPk=withPk, **options)
